Every year, the core developers meet to discuss and propose the major changes and trends in Python itself. This invite-only conference of about 50 people happens inside PyCon in the US. Because it's private, we rarely get detailed looks inside this event. On this episode, we have Seth Michael Larson here to give us his account of the sessions and proposals. It's a unique look into the zeitgeist of CPython. This is Talk Python to Me, Episode 475 recorded August 22nd, 2024. Welcome to Talk Python to Me, a weekly podcast on Python. This is your host, Michael Kennedy. Follow me on MassedOn where I'm at M Kennedy and follow the podcast using at Talk Python. Both accounts over at fostodon.org. And keep up with the show and listen to over nine years of episodes at talkpython.fm. If you want to be part of our live episodes, you can find the live streams over on YouTube, subscribe to our YouTube channel over at talkpython.fm slash YouTube and get notified about upcoming shows. This episode is sponsored by Posit Connect from the makers of Shiny. Publish, share and deploy all of your data projects that you're creating using Python. Streamlet, dash, shiny, bokeh, fast API, flash, quattro, reports, dashboards, and APIs. Posit Connect supports all of them. Try Posit Connect for free by going to talkpython.fm slash Posit, BOS IT. And it's also brought to you by us over at Talk Python training. Did you know that we have over 250 hours of Python courses? Yeah, that's right. Check him out at talkpython.fm slash courses. Hey, Seth, welcome back to talkpython.me. Hey, Michael. Awesome to have you here. I'm really excited to get a look into the zeitgeist of the core devs and the people building Python for us through the Python language summit. Yeah, let's do it. Let's do it. So we're going to talk about the 2024 language summit that happens in Pittsburgh. It's like an embedded mini conference inside of Python, which is smart rather than trying to travel all over. But before we get into that and all those things, I know you've been on the show not too long ago, but for those who may have missed your introductions, you know, who are you? What do you do for Python these days? I'm Seth Larson, and I've been working at the Python Software Foundation for a little over a year now as the security developer in residence. And so that means that I do a lot of stuff related to security just for the entire Python ecosystem that's CPython, PIP, packaging ecosystem, like outwardly facing things for PyPI, maybe not as much the internals. I leave that for Mike Feadler, the PyPI safety and security engineer. And I maintain a lot of open source projects specifically in like the HTTP and internet space. So like requests, your lib three, trust store, things like that. Awesome. Yeah, thanks for everything you're doing there. And how's the as the role working out? I know this is one of you were the first person in this role, like officially, right? Is that true? That is true. Yeah, I was the first security oriented hire at the PSF. It's been going really great. I mean, I feel like we've made a lot of improvements. And there's a lot of exciting stuff that I'm working on today. And I don't know, I think one of the things that also got highlighted, because this role exists, it just means that more people at the PSF and in CPython core team and just in the Python ecosystem in general are talking more about security. And like, that's just as important as the stuff that I'm doing day to day is that it's just there's just more awareness of what's happening in security. Yeah. So I have two polar opposite thoughts here. One is, I'm really surprised how few significant issues there are in Python, CPython, you know, the interpreter, the runtime, the standard library, all that. It's really rare that you get a red lights flashing. Oh my gosh, go patch your systems now. There's sometimes really minor things like this audit trail is not completely followed under this condition. But that's not a the pager goes off in the, you know, because you got it's now a race. That's one thing. So that's awesome, right? That the other is type I type of squatting all the all the stuff that makes Python extra good, the half million packages and other shady things people do. And we're going to talk about this in the broader sense, not pipe, yeah, but you know, in the open source space of like, well, what if what if somebody took over a GitHub account for a little while or or something? Yeah. So in that, that's not on fire, but that's yeah, there are battles being waged actively there, I would say, right? 100%. So it's a contrast, right? There I can speak with confidence that there is malware on PIPI right now as we speak. But like, yeah, so that's that's the case, right? I think it really has to do with CPython is an incredibly mature project in like every sense of the word, like governance, security, design, all of these things, right? And like, there's just a huge amount of people and resources being being like working on CPython at any one moment. And like, contrast that to the, you said half million, you know, I tend to focus on the like 95% of downloads by totality, right? Because there's a lot of projects on PIPI that maybe don't have the supply chain criticality of others, right? But yeah, absolutely 100%. And when you I think when you hone in on that smaller window of projects, it ends up being a much better picture than I think it's 100% good picture, honestly, there are legitimate bugs that people have to deal with. Like, you know, maybe there's a Django release that says we didn't validate the CRF token in in this particular form. So you should update your Django, right? And that's that's just a legit bug. That's not yeah, people attempting to do bad things. And I mean, I can't even take really any credit for how secure and mature CPython is. I'm such a late addition in the life of CPython and like PIPI projects. And so it really is the community. I think it is just there's so much investment and so much love and care happening in all these projects that it does speak volumes. But that I mean, that doesn't mean that we need to think that things need to be perfect, or that it's necessarily a bad thing to have a vulnerability in a in a project, because there's projects that are even more mature than CPython that have vulnerabilities all the time. It's totally normal. I think the important thing is just like knowing what to do when that happens. And that's where I come in. Yeah, I don't want to belabor this because you know, the security angle, wow, interested in me and central to what you're up to is not the topic. But I do think it's interesting that the White House recently came out, I think it was the White House, it said, we recommend Python and a couple other languages. We basically we recommend memory safe languages, which did you see that post? You must have right? I certainly did. And I actually had a big part of recommending that to the White House. So when the no kidding, I had no idea. Yeah, yeah. So the the PSF, we responded to the request for information that Sissa put out, or the office of the cyber director put out, I think a year and change ago. And in that post, we recommended CPython and Python in general as a memory safe language, and went into all the details about like, yes, it's written in C, but like the language itself, what people will actually be programming in is Python. And we also emphasized how Python is a bridge into memory on safe languages. And because of all the focus on performance lately, it's actually like sometimes in some cases, more performant to keep the code written in Python, as opposed to writing it in C. And so we emphasize a whole bunch of stuff. And so I think that that had a small percentage of the reason why that was recommended. But it put it on the radar and positioned it correctly, maybe. Exactly. Awesome. Well, congratulations. I was just going to say that's kind of interesting, but I'm going more to it than that. There's a lot happening behind the scenes. Yeah, yeah, yeah. Yeah, there is. All right, shall we talk about this language summit thing? Let's do it. Let's do it. So let's just, I mean, I gave it sort of a vague intro. You wrote a nice blog post about it here on the Python blog. Just give us a sense of what the language summit, what is it for? Is this something is like an open space I can go to or not? No, so it is it is a specific space for Python core developers to use. And so I think the whole goal of this is to get a bunch of core developers in a room together to discuss things and to kind of get some recommendations, some ideas flowing, maybe without necessarily having the full formed thought, right? Because putting something out there, completely radically changing the direction of Python, that's a that's a lot to put that out just publicly, whatever. And so this is a place to collaborate for core developers and some special guests, because they're not everyone that's there as a core developer, but it is invite. So you have to apply it to go and say why you want to go. And then yeah, so it's just folks who were, remember, if it was Sebastian Ramirez or same you call owner, something around the typing thing. I remember some of those folks might have been at one of them because they're like, wait, we can't change typing to be more performant, where to completely ignore the runtime stuff because we have all these frameworks. Right, right, right. Yeah. Yeah. But the language summit, it's a whole bunch of different like submitted topics, people will talk and then there's discussion and some outcome. Maybe there's no outcome. Maybe there's like next steps. Maybe we solve some problems within the time of the meeting. And yeah, my job there was to actually like take down all the notes and write about it and like publish these blog posts. Because one of the one of the reasons why this is allowed to be like an invite only meeting is that there is someone who is basically taking notes and blogging about everything that gets discussed. And like what happened during the discussion so that the community can learn about what actually happened without necessarily, you know, getting the rawness of it, I guess. Yeah, there's a role careful balance. You got to strike between allowing the freedom to say whatever without public scrutiny. But at the same time, you don't want to be like, well, the Python cabal met, they've decided exactly. They don't like, they don't like your idea or whatever. Exactly. Yeah, it's cool. So I'll point people, obviously, it's going to be in the show notes. When people at your write up, it's like a meta post, I guess. Would you say that? It's it talks about, you know, sort of landing page, landing page exactly four, one, two, three, four, five, six, seven, eight, nine, and then nine topics and presentations that were covered. And then the lightning talks, which is also almost like another sub meta section. So there's a there's a lot to explore here. And there's nice writeups on each of these. So, where should we start? We want to wrap up the conversation we were just having, because that was actually a little bit of a topic at the language summit, right? Yeah, security was definitely a topic at the language summit. This this was somewhat in the in the recent light, like the light of XZ when XZ had happened, Pablo, one of the release managers for CPython 310 and 311, I believe, brought this topic. And it was basically discussing Python's like contribution and release and all of that model in the light of XZ. So like XZ, I'll just go over really quickly. Yeah, yeah. I'm sure a lot of people has like heard of it at this point, but it was such a long game deal. It was crazy. So yeah, what is the scary part? What is XZ utils? And then what is the XZ utils security issue? Yeah, so XZ utils is a library written in C for basically processing archives of the XZ format, which is just a compression format, like G-zip, like any other compression format, zot flea, rottley, all of those. And so this library was maintained by a single person, big surprise. And what is relatively little known, right, before all of this happened, I would say. It was probably just adding features, fixing bugs, everyone's gonna make a release and all of that. And what ended up happening is this project was identified as a project that had very few maintainers and also through a series of reasons had a linkage to SSH. And so it ended up happening. Yeah. And so SSH was- If you can get into SSH and SSHD, then bad things are gonna happen. Yeah. So the whole end goal of this entire operation was to get access to open SSH through like linking basically. And so what ended up happening is a bunch of fake sock puppet accounts showed up after this lone maintainer indicated that they were having a little bit of trouble maintaining the project and like meeting user demands. Like these sock puppet accounts show up like days before they were actually used and all kind of in similar fashion, right? And basically are pressuring this maintainer to either make them feel like they're not doing a good job or to try to add a new maintainer, in this case, Geotan, is the pseudonym that this account used. And what ended up happening is over a year of like legitimate positive contribution from this account. This account was added as a like equivalent to a release manager, right? Like someone who is right, right? Approving PRs and merging things and is capable of accessing the actual archives when releases happen. And then a good chunk of time passes after that. And there's a couple of little changes added that on their own are not an attack, but it was preparing for an attack where essentially a small change was added into the release archives that was not a part of the source tree that activated the entire attack chain. And then when this started to like be pulled in downstream into things like, you know, Fedora, early versions of Red Hat, this never went into any stable builds, but it was all the pre releases. This ended up getting onto people's machines and then was eventually discovered because of a very small performance difference when logging into SSH. And yeah, and that was somebody who wasn't even looking, forgot the person's name, but they worked at Microsoft and they were just the Azure team or something. And they just were like, why did this slow down a little bit? That's weird. And they're like, wait a minute, what is this doing in here? Yeah, it was on the verge. And you know, what a long game. One person, one account came along and was just, you know, I'm going to hear to help you. I'm just going to make, I'm going to try to just become your best friend contributor. And then another one is just abusing, like mentally abusing the people like, why don't you just quit? Why don't you get some more support? And then like, who? Well, let me reach out to some people who are helping me out recently. And it turns out these are like two sides of the same coin. Yep. Exactly. Yeah. Shady. Okay. Luckily that got caught because, you know, there's a lot of servers in the world that can be SSH into and like, well, we got, you know, public private key encryption. You can't break through that stuff. Long as you don't use passwords, like you're going to be fine, unless you're not. So I received a lovely email on the day that this happened. Report to the security response team for Python, because we, of course, use the XZUTils libraries, because Python supports XZ format as well. And I, there was a, there was a lovely few seconds where I'm like, oh, this is either going to be a fine day for me or a really bad day. And it ended up being a fine day. So that's good. It's like, are we going to be canceling all our plans for next year? Yeah. Yep. Am I going to have lots of questions to answer from like a concerned customers, users, but it was fine. Yeah. Yeah. I find this kind of stuff is a lot like everything's fine. You relax. Just works going good, life's going good. And then, you know, something's on fire just out of the blue. And you have this, you know, it takes your breath away moment. Like, Oh, does that apply to us as well? Because if it does, everything just changed. Fun fun. Yeah, I'm really glad I did. This portion of talk Python to me is brought to you by Posit, the makers of shiny formerly our studio, and especially shining for Python. Let me ask you a question. Are you building awesome things? Of course you are you're a developer or a data scientist. That's what we do. And you should check out Posit Connect. Posit Connect is a way for you to publish, share, and deploy all the data products that you're building using Python. People ask me the same question all the time. Michael, I have some cool data science project or notebook that I built. How do I share it with my users, stakeholders, teammates? I need to learn fast API or flask, or maybe you view or react. Yes. Hold on now. Those are cool technologies, and I'm sure you benefit from them. But maybe stay focused on the data project. Let Posit Connect handle that side of things with Posit Connect. You can rapidly and securely deploy the things you build in Python, streamlet, dash, shiny, bokeh, fast API, flask, quarto, ports, dashboards, and APIs. Posit Connect supports all of them. And Posit Connect comes with all the bells and whistles to satisfy IT and other enterprise requirements. Make deployment the easiest step in your workflow with Posit Connect. For a limited time, you can try Posit Connect for free for three months by going to talkpython.fm slash Posit. That's talkpython.fm slash P-O-S-I-T. The link is in your podcast player's show notes. Thank you to the team at Posit for supporting Talk Python. One of the talks was Python security model after this issue, the XC, E-Tails backdoor. Tell us about that. Yeah. So this entire talk was essentially just overviewing like, hey, is this possible? Is this possible for C Python to be impacted by such an attack? And I mean, the answer is yes. It really is. Because if you have accounts that are willing to put years of effort into contributing good code to C Python, right? Like that is enough to become a core developer likely. And if you're a core developer, it means you can merge PRs. It means if you get two core developer accounts promoted to this level of authorization, you can merge your own PRs with review, right? Like, the big focus on this talk was like, okay, how can we prevent this? And if we, in the ways that we can't prevent it, how can we be ready? And kind of like a discussing whether or not we're ready at this point. And I think the big consensus was that if we were to discover something like this, it had already been merged into Python or had been released in Python, that we would be okay to be able to get it to like get the word out. Like that sort of infrastructure already exists. And we're not too worried about that. Like we're CNA, we can create a CV really quickly, we can get like the announcements out really quickly, we can get releases out really quickly. So like in that way, the reactive sense, we're okay in the proactive sense, there, which is the more important one, but it's also the harder one. We yeah, because when nation states hire people to say the next three years of your job, it's almost like it's like a team like a spy. Yeah, for three years, exactly. It's like the CIA or MI six or something, you know, it can all be on the code side, you know, to be honest with you, it doesn't even need to necessarily be like nation state level stuff for this to happen, because vulnerabilities in popular pieces of software are very, very lucrative. You can sell them and people make a lot of money on selling vulnerabilities to projects. But so why not grow your own, right? Yeah, so go ahead. One of the things I think is great, there's a really long release cycle, right? And like a stage rule out. So I don't know how many people jump in and install alpha one of some Python, but it's pretty limited and it's not going to make it. No, no, of course, I know as he raised you in. However, I don't see that shipping on, you know, Ubuntu's update channel or or Docker's whole different deal. Like let's not even go there, but on the main Docker images, you know, yeah, yeah, I mean, this the slow rollout is is definitely a big part of it, right? Like a lot of people get their Python not direct from the source, they get it from a like a distribution or they get it from, you know, if they, you know, like Amazon Linux with Python or whatever, right? Like it's a distribution of Python or brew install or brew install Python. Yeah, so a lot of people are not living on the edge. And I think that that helps in a way. Obviously, people that are living on the edge, maybe they're the more valuable targets, but I mean, I'm not going to be the one to encourage that. Yeah, I don't think that I think the biggest defenses against this, and this was what was discussed there was trying to push things to be in the open. And actually, in a way, open source is uniquely able to respond, right, right, right, right, right, defended against for these sorts of attacks. Because if this were to happen in Windows, for example, like, would we have had the almost immediate, like, being able to debug what the actual attack was, how long this would have been going on, what patches were bad, right? Like that, that sort of visibility into the source code is something that was really important in being able to actually track this thing down. And so like having test files and binary files not checked into source code, and instead generated. So one of the parts of this attack that allowed it to go hidden for so long and be checked into source code was that almost all of the attack code was hidden extremely well in a binary file, which made it so that code reviewers could- Some of the test binary elements, because if you got a compression file utility, you got to have compressed files for your unit test, right? Exactly. So it was basically these files were checked in, and there's just huge binary blobs that you can't actually get your eyeballs on to review. We talk about like lots of eyeballs make for shallow bugs. Well, if the eyeballs can't see the bugs, then you're not going to find them. And so we talked about like removing binary files from the source code, or making sure that all the binary files that are generated have like a script that allows them to be generated anytime and things like that. Is it one of the changes? I can't remember if this was on IPI or if this is a GitHub thing, but allowing GitHub to be the thing that publishes directly builds the wheels and uploads them to IPI, rather than somebody downloading the code, building them and uploading it, which obviously that's a opaque step there. Yeah, so other things that tie more strongly, these whatever release artifacts are actually ending up on people's machines to the source code. So that's, I mean, I would call that build provenance. There's a whole bunch of different frameworks that that works under, but yeah, build provenance being able to tie in an artifact that's installed in your system back to the actual source code so that when you are evaluating that that artifact on whether you want to install that on your system or deciding whether to upgrade or whatever, you can look at the source code instead of writing this like compiled binary. That's something that I really want to focus on for like, PIPI in the future, but yeah, we're not there yet. Awesome. Yeah. When you, because when you look at a project, you say, well, let me let's see what the release is on GitHub. If you know that literally that was the thing that compiled or got built, and then that's what's on PIPI, that's a different forensic analysis than exactly. Well, it's somebody's machine. What it ends up nice, like being nice is that it, and this is the tough part is that I feel like a lot of people's behavior, which is to go on GitHub and look at the diff between like tags. That's what a lot of people do, but that's not actually what you should do. You should be looking at the diff between artifacts. That's the thing that's actually installed on your machine, but that's way harder to do than looking at the tags. So, adding build product. We just crowdsource it. We're all crowdsourcing it like, wait for some way. We are. I know where we are. All right. We're just related to this while we're still on this topic. You know, you talked about the somewhere. There we go. There's also big news around CVEs, which are official vulnerability numbering. So they're taught, they're referenced through all those cybersecurity talk and stuff, right? You should be better. But so big news is that the PSF now, and you alluded to this, is now an official numbering authority. So rather than saying there's a problem with Python, who's going to sort of officially call this out and write it up and so on, like you guys can do that directly now, right? Yeah. So like CVEs are basically, it's a set of identifiers and records that show, it's like a bunch of metadata about vulnerabilities in software is what it is. And it's only one system. There are a bunch of other like vulnerability databases, but CVE seems to be the one that everyone uses or references. And so what being a CVE numbering authority gives us is it makes it so that someone at the PSF can like operate the CVE UI and workflow and all of that to say like, oh, we want to create a new CVE ID on behalf of the Python team or on behalf of the pip team. And what that ends up meaning is that because we are part of the process instead of having to go to some other entity. So like, MITRE or Red Hat or, you know, Microsoft, there's a whole bunch of CNA. So there's a over a hundred now, I think, instead of going to someone else that, you know, isn't as well versed in Python or, you know, our release schedule or any of those things, right? We get to inject the knowledge that we have about Python into all of these records, into all these advisories. And it makes it so that we don't actually have to talk to someone else to be able to handle a vulnerability end to end, right? So like before, you would potentially have a reporter going to talk to someone else and getting a CVE ID and then they would come talk to us. And by that point, like it was, it's hard to like make a determination and there's a whole bunch of things have already happened. And maybe there's messes that need to get cleaned up to make sure that it's not confusing. So by owning the entire process, we're able to make sure that things are as little confusing as possible, like what actually needs to be done for users when we publish these things. Yeah, that's, that's great. I want to move off the security angle here, because I know there's so much more to talk about. However, and help it, you guys do it. Have you considered or ever run any sort of bug bounty program? We don't have a bug bounty program right now. I mean, the hard part with a bug bounty program is it takes money. So if you would like to see a bug bounty program happening at the PSF, get in touch with the PSF, send you know. Yeah, I think incentives are really lying there. There's a lot of companies that have this tooling at the center of their data center. So maybe, maybe, maybe we can make it happen. All right. Next up, the REPL or the py REPL for the Python py REPL. What's the deal with this? Yeah, so this was a a talk that was given by a couple of different core devs. I think this included a bunch of people Pablo, the caution, Los Andros all gave this talk. And it was about, hey, this new REPL that's coming in Python 3.13. Here's all the cool stuff that it can do. And how it makes the usability so much better for people. And they demoed a whole bunch of the new features, which was really exciting. There was lots of applause showing off a few of these like little little features. And I think that the other side of it is like, because this new REPL is written in Python and not written in C, it lowers the barrier for contributions and maintenance drastically. Before the REPL was like super entwined with like the parser and all of these other really low level details of Python that a lot of people probably didn't want to get involved with if they didn't have to versus this where it's this completely separate and much more easy to to contribute to piece of software. Yeah, and did this come from the PyPy py py project? Yes, this was py py. And I think that there's been some some back and forth contributing back contributing forward all of that, which is also really great, right? Having one REPL shared between two different implementations. Yeah, that's great. Just working better together, more people working on it. I always caught people I P who I guess some people call Python packaging injects, PyPy, but that's also another thing. So anyway, it's a not part of every one of my days, right? Because a lot of the times, a significant percentage of my work as a security person is being in working groups that are not Python related at all. And there's a lot of pipelines flying around. Yeah, you talk about NumP B and on PyPy and you're like, okay, hold on. Hold on. Could be two different things. There's a lot going on here. No. Yeah, so this is really interesting. I haven't really played with it much. I honestly don't spend a ton of time in the bare Python REPL. Like if I'm a REPL a lot of times, I'm in the JetBrains sort of enhanced REPL that's inside PyCharm, something like that. But and I think partly because there was a lot of challenges with the bare Python REPL, right? There's no auto complete, but worse than that was if you've got a five line function and you want to edit it, you've got to go out to the top heart hitter. It really was hard to work with blocks of code. There's no color, things like that. Yeah, color is the standard for you don't have color in your terminal at this point, like even 20. Basically, you've given up at that point. If you have an emoji and you don't have color, I mean, emoji is cooler. Gotta have like the rainbow prompt to maybe like the logo of the thing that starts up. A starship. Oh, yeah. I didn't even consider the ASCII art, and possibly the ASCII art in color. No, seriously, though, I do think it sounds like a minor deal, but just the readability of having highlighting and stuff. Yeah, it's really nice. Highlighting is huge. Syntax highlighting is really huge. That's not a part of the current REPL, I don't think, but it becomes much more possible because this py REPL exists. Yeah, exactly. Yeah, they're cool. I think that the biggest thing, the whole blocks of code, I just remember the demo of them showing, oh, you have five lines, you have to hit up up up four times, hit up. Oh, you've messed it up. You've got to start over. You've got to start over and you're just sad. You just contemplate putting it in a file instead of doing this in the REPL. Exactly. That's why I'm running there. I avoid being in there because it's hard. This will be really, really great for people that are just starting Python journey because I think that a lot of people learning and starting off will use the REPL straight up instead of an IDE. There was a big focus on teachability and documenting it and making it work the same. If you actually read the post, what the discussions were about for everyone who's basically totally in favor, they loved it, but they wanted to make sure that this was going to be a consistent experience. Specifically, Carol Willing had this big point about having a consistent experience being really important for teaching Python across different operating systems. Yeah, it's been a little bit better than up up up five times and don't get out of order. Exactly. Yeah, that's cool. I guess one of the, I don't know if this was discussed, but one of the challenges to this, I think, is it requires, and it's not necessarily bad, but just a challenge is, I think it requires the new Windows terminal rather than say, CMD.exe, the older style. It just works out of the box on macOS and on Linux, but on Windows, you got to be a little careful about how you run it. Is that right? I actually don't know what the current status of all this is because the time has marched on since these blog posts have happened and there has been a lot of work done on the Windows side. The current team, like the team that presented this didn't have any Windows experience. And so they didn't know really how hard it was going to be. I think that there's been a lot of strides in the Windows side of things. So I think the situation's better. I don't know offhand if CMD.exe is supported or if it's just the new Windows terminal, but I think it's fine. I've seen it when it was terminal. People need to be using that thing anyway. It's like opening up on your Mac and just having like the bare white bash. I guess it's Z shell these days, but just the completely non-fix font. What is this thing that you are running? The terminal is horrible. Well, that thing is, but you could make it a lot nicer, by the way. And it's similar trade off there in the Windows world. So, okay. Interesting. Next one is, should we adopt calendar versioning? We're beyond zero-verse. So that's really good. But there's been a reluctance to have Python 4, but we've got 3, 12, 3, 13. Are we just going to have 3.128? Or should we come up with something else, right? What is calendar versioning? And should we adopt it? And how many digits should it have? Yeah. So this was presented on by Hugo, who is the new release manager for Python 3, 14, and 15, which maybe that's a little presumptive, saying those numbers. Because if this goes through, that would not be the case anymore. He's going to work himself straight out of a job here. Let's go right. Yeah. This was, there were definitely jokes about like this is just your attempt to get out of being the release manager for these releases. But yeah, so Hugo proposed this. This is kind of like a pre-pep feeling out of how this situation should be. And like, trying to pair down the options, I think, was Hugo's biggest question. What should we do it? And should we pair down the options? Because there's a million different ways we can do calendar versioning. And yeah, I think if you scroll down, there was like a slide that had just every single possible calendar versioning possibility for Python and all the different languages. But yeah, calendar versioning is like really common for programming languages and other things that are similar to Python. And so this was basically like, hey, we have this yearly release cycle that has been working for a while and we're probably going to keep doing it. It's worth pointing out for people who don't know that it used to be 18 months. And so the calendar versioning would get a little out of phase or something there. But now that's yearly in the fall, it really lines up perfectly. Yeah. And so this kind of assumes that we're going to keep doing the yearly thing, which I'm fine with the yearly thing. But yeah, as long as we kept the yearly schedule, it would line like the release year would line up with whatever the so would be like the ended. The one that was like most agreed upon was like three dot and then a two digit year or what would end up becoming a three digit year when we roll over to 100, assuming that Python's still using them, you know, 100 years. But yeah, so like that was kind of like the one that was most palatable to to core devs or people were most excited about. And I think the big reason why switching to like a calver year was interesting is that we have this thing called like support lifetime. So like how long is CPython supported? How long do you get security fixes? How long do you get bug fixes? Right. Let me is it? Yeah, exactly. Like let me put this out to the audience. Is Python three eight supported or is it not supported? I don't know. You got to do you got to do math. You got to think about it. Yeah. So three seven just recently dropped support, right? Which is crazy. Because that seems like a pretty new version of my mind. But it totally makes sense. But if you just knew it's supported for how many years six years five years? It's five years for security releases, I believe. Yeah. So then you're like 2025. So you know, 2020 out becomes a lot easier. And there was also say like, do I have the current one, right? If you're not tracking it super carefully, like 311. Is that the latest? Like, I don't know. And I only just by thought every like once a month, well, it's a 2023. Oh, I see. Well, I mean, that's not the latest one. Okay. Yeah. So it was just interesting conversation about figuring out what the best potential option was. And then Hugo ended up creating a pep. And I think that's being discussed right now. So cool. Why not 2024? Why 24? Because that feels, I don't know, it just feels like you've just point shifted what you're doing now, rather than then really clear. Because you know, as a new person coming in, you don't see that go it's 24. So it must be 2024. And unless you really like put together the calendar, but if it's a dot 2024, you're like, I bet that's the year, you know, right? Yeah. I mean, because eventually that in the not too distant future, there will be a Python 3.24. Exactly. Yeah, we'll see. So there's going to be a pepper on this, you say. In fact, it says right here, PEP 604, right? I think it's PEP. What is it like? Oh, wait, no, that's just the yearly and absolutely scroll down all the way to the bottom. It'll I think it's like PEPs. Yeah, there's a lot of drafting. It just says drafting a PEP. Give that a click. I'm pretty sure there's a number 2026. There we go. Okay. Yeah. Oh, so that's going to be a while. So they release this PEP. Well, so the most the most important part of this discussion was that the Python version 3.14 be be preserved. Python. Yeah, cool. It wasn't allowed for 3.14 to change it. Yeah, the only thing that I can think of that you would have the two digits is that there's a lot of code and regular expressions and junk out there that checks for that. But you know, if we talk about some of the other stuff out there, like that's a pretty minor change. Like, for example, pre threaded Python. Yes, pre threaded Python. It's here. It is here. Sort of. Yeah. You know, what actually really surprised me is that when I saw this PEP come through, was it 702 or something like that, it said, we're going to allow free threaded Python, which I'm going to have you explain for folks in a moment. But you're going to have to have a special build of it. And I thought, oh, well, that means if you want to play with it, you're going to have to build your own. But I noticed that the installers now give you an option for it. Yeah, they do. Yeah, the inside by side install, right? Yeah, the what is it? I think there's like a T that gets put on to your actual like, yes, Python T is what you type instead of Python. Yeah, if you want the free threaded one. Yeah, it I mean, free threading is here. I mean, there's options. If you're compiling yourself, you just enable some options. And I think I go over that in the actual blog post to the options that you actually use to try it out. And yeah, free threading essentially is it's a way to remove the Gil and move to a different like reference counting model object counting model. And which is quite exciting for a lot of people, but it will what it will end up meaning is that a lot of the packages that are written in C or that are relying on CPython APIs will have to get either, you know, tweaked a little bit to like use these slightly different C APIs to make it so that they play nicely with having no Gil enabled and with the new memory management. Yeah, it's super exciting changes in the ecosystem, basically. Yeah, just because you have threats doesn't mean you get perfect scalability across the cores. Can't remember who wrote this article. Simon Wilson, maybe who did some yeah, I'm pretty sure Simon Wilson wrote one that said, look, we're going to take an algorithm that can is kind of embarrassingly parallel and parallelize it. And it turned out to be something like 50% gain per core. So it was like he had eight cores and it was four times faster with rethreaded Python than without, which is still if you can get your code to run four times faster, that's still really good, right? Yeah, but it's it's going to have, like you said, I think it's going to have an interesting requirement put on all the people building packages, right? Yeah, I know when I hear people say, I think maybe you just said like, oh, it's going to be the the C extension packages that are really going to have to deal with it because they they will have to do locks in their thing. I think even in the Python code, there's certainly algorithms that have multiple steps that they'll get some data here, they'll work with the data, they'll make some changes, then they'll put the data back in the same place. And even that would be subject to a race condition, right? And I think we're, you know, I've in long in the past, did a lot of C++, I did a lot of C sharp. And in communities like that, people are like always focused on like, always kind of crazy about two things memory and threading. And we just don't do that in Python. We just, I think we have just leveraged the fact that the Gil gives us kind of enough coarse grained granularity, the execution of our code that is just not something we hit a lot. And we don't try to do a ton of threading because it doesn't work all that well. However, this, this could expose lots of stuff. This could put a new focus on that. Yeah, yeah. Just having more people using threading with Python, that that's going to be huge for finding thread safety issues. Yeah, it's, it's just really exciting. I think that, and there's another blog post to completely separate one that talks about like the C API. And there was some mention about like free threading and evolving the API so that it's a lot easier to use from a free, a free threading perspective. So like there's a ton of work happening in here to make this as easy, hopefully brief kind of split in the ecosystem and then have it converge together. I think that's like the overall plan is like, okay, we got to, we got to have a way that if this is really not working out, we can go back. But if it is working, we need a way that we can actually land this thing as the default. Right. Right. Right. And the PEP discusses this as like, we're going to, we're going to see how it goes, which is really interesting. But I think it's not breaking in the sense that you can't still run Python three with the thing that you've got, you just might not be able to enable this free threading aspect of it for some time. Whereas from two to three, it's like, you cannot run this library on three period. There's no scenario which this is going to work because it needs to take into account this and it doesn't. And so it's out. So I feel like there's more time and space to evolve it. And you could say, well, in this space, you know, this data science section of the world, we use these seven libraries and we're going to work and make them compatible so that we can get way better performance or, you know, we're going to work to make sure that fast API and PyDantic support it really well so that we can scale our web servers better. Whatever. Yeah. No, this will be huge for, for like web and data. I think that a lot of people are excited for this for a really good reason. Yeah. Yeah. I totally agree. I totally agree. Okay. So this is a big deal. It's coming in three 13, but you've got to run Python T for now. Yeah, it's a three 13, but it's also available in the pre releases. The first release candidate for three 13 is out. So give it a test. If you haven't given it a test, give it a test. Yeah. Very cool. All right. What what one do we want to talk about next? We got just a couple more minutes to cover. We've got what about Python and mobile? I think that one's I know there's the the black swan talk that Keith Russell McGee gave and Carol Willing also sort of shouted out like there's a couple of places that are really, really important computationally in the world that Python kind of isn't. We should have it there. And number one has got to be mobile. Yeah. Mobile in front end. For me, mobile in front end are the two. And like a far distant behind that is like, could I get a single binary out of my app that I can give to someone? That's a different that also is in there, but it's it's like not as important as hey, I want to I want to build some mobile apps. Can I use Python? You know, I want to learn and that with an easy language. Can I use Python? Like, ask me something else. Yeah, yeah, right. Like next question. Yeah. So this was this was a it's almost like a big status update on where Python is in the mobile space, which is really exciting because they've made a ton of progress on getting like actual tiering of support for these platforms. So if you don't know, Python has a like platform support tiers where it's like tier one is like x86 Linux, right? Like that's a 90% of Python downloads are that like, yeah, probably want to support that one. And then as things like Mac OS, you know, x86 and ARM and all of that, right? And then lower down there's tier two, which is, you know, the platforms that they have people that are interested in them. But if those people were to go away, then we wouldn't actually have a way to support them. And tier three is like even more so, right? So having tier three support for Python for both Android and iOS for 313, like that's super exciting. It means that these things are getting actively tested. There's like integration testing on real platforms, and that there's people that care about it that are fixing bugs. And this is exactly what you need to get your platform supported. And so this is all being provided by Anaconda funding this project and be where. Okay. Yeah, that's right. They are, you know, be where and Keith has been on this for a long time, but Anaconda have come along and put more time and energy behind it in terms of funding and, you know, people as well, I'm not sure, but certainly in funding, that's awesome. Yeah. So I think this was, it was both a status support and also kind of trying to figure out how these sorts of platforms can get tested more easily and like actually not having constant breaking because these platforms are so different from, you know, what almost every other core developer is using to develop Python are a lot more limited in terms of capabilities and like lock down in a security perspective too. And they have no regard for backwards compatibility. I had so frustrating. I got, I, you know, I have mobile apps for the top Python courses that are in both iOS and Android's app stores. And I'll get messages like, Hey, dear developer, if we see that you're built against three year old APIs, if you don't rebuild and republish your app in the next six months, we're taking it out. The last one I did this for was Google. I'm like three, three years, okay, we know I can't get any better compatibility than that. Like I just got to keep re uploading the same thing, even if there's no changes. Like, so, you know, that's just a different mentality of like, yeah, we changed all that. We don't like that anymore. Yeah, luckily, I'm actually not sure how affected Python in particular is by things like that, because that's like utilizing APIs, like mobile SDK APIs versus like the operating system of the phone, which yeah, right. Like people would build apps with Python and then they would be subjected to these emails. And it's not even that I was necessarily using any of those APIs. It's just like, we see your compiled against the wrong version. So try again, you know, yeah, no, the, yeah, the difficulties that I've at least from, from this talk have figured out is that like these platforms are just a lot more locked down. So like a lot of system calls won't be available that the test suite, like assumes are available always. And sure, it's almost like a circuit Python sort of deal, but exactly. It's like, yeah, it's like somewhere in the middle and figuring out how to all work together happily and develop on this similar code base that has all these different target platforms. Yeah, absolutely. Absolutely. Awesome. Well, I'm, I'm really excited. I'm all here for it. If three years ago, I think it was, when we started working on those mobile apps, if I could have used Python in a really solid way, 100% those apps will be built in Python. But just there's so many so much tooling and stuff around now, you got to create a signed APK before you uploads. There's a lot of stuff going on there. And so hopefully they get that that would be a game changer. And just, you know, it's not on, it wasn't here. Almost surprises me that it wasn't here. But front end stuff, web assembly, Pisces, grips, Pyodide, all those things, I think are in that same realm. Although they can just kind of ship stuff to the web because there's no gatekeepers, but still. Yeah. Was that mentioned anywhere during the, the summit that just didn't make a post? No, a wasm was not, there was no topic about wasm specifically at, at this language summit. Yeah, sure. I think there was the previous year. Previous year there was. Yeah. Should we make PDB better? Does matter? Are people using PDB? What do you think? Yeah. So this, this was all about PDB is Python's debugger for people that don't know. If you've never used it, it lets you kind of like drop into, set a breakpoint in Python and then drop into that exact spot with all the context and everything, which is really a lower level. Yeah. A lower level than a VS code or PyCharm. Right. Exactly. Yeah. Like, seeing all these like super internals of Python, if that, if that's something that you really need. Right. And so this was a talk that was mostly about, okay, we're, we have PDB, but now we have all of these new models, like free threading and all of that. And also we're being a little bit held back by backwards compatibility. There's like a specific, really specific point where because of backwards compatibility reasons and PDB is a part of the Python standard library, it becomes difficult to break backwards compatibility, even if it would mean you get a bunch of really good stuff out of it. You can't always do that because people are depending on it. And I think that the, yeah, the recommendation was maybe we should develop this outside of the standard library so we can, you know, be yeah, break backwards compatibility if it's not necessary and make it so that we can support multiple versions instead of just having a be per version. Yeah. Yeah. That's, that's a good idea. That's exactly what I was thinking. Because, you know, there's the whole dead batteries talk like, did this still belong here? I'm not necessarily thinking this should not be in Python, but, you know, yeah, something broken out maybe, but take that exact code, break it out, but, you know, enhance it kind of independently. Yeah. I think the concern from, from some people in the room was that, oh, if we break this out onto Python, it would potentially mean that it would not get the same level of contribution that PDB sees because it's a part of Python, right? Sure. And I mean, totally valid, in my opinion too, like being a part of Python is a huge, like blessing of like, yeah, this is something important, right? But I think that there's, there's other ways to signal that it's something important. Like if you look at like my pie, my pie is underneath the Python GitHub organization. And so maybe something like that, right? Where it's this tool that is very actively used by core developers for development. And it is a little bit more official than, you know, just some random person putting something up on PIPI. This is core developers supporting this. And black is that way too, I believe, right? It is. Yeah. So maybe something to signal just a little bit more of an official, this is a core developer tool. Here's why you should contribute to it instead of just, you know, a random project on PIPI, which definitely wouldn't be in that case. It would not. It would definitely not. All right. How about, how about a quick review of maybe some of the lightning talks? Yeah. Any of these stand out? You know, I was, hey, rest in Python is seriously one. Yeah, Emily's talk was, yeah, I was saying, Emily's got a good one. Emily has a really good one because, and this is like, it's, it's almost meta, right? Because lightning talks are not submitted ahead of time. You actually have to submit them during other people's talks, like to the list that you want to talk about this and then put together some slides really quickly. So yeah, these talks are pretty impressive in that way, having mere minutes. But the Emily's talk was about, it was kind of like wrapping up a theme that was being heard multiple times over the course of the language summit. But obviously, this is a problem outside of the language summit too, which is that when someone goes to make a prototype for a PIP, they are given, at least today, not a whole lot of support for doing that prototype because it's basically like, oh, we think that this should be developed outside of the standard library, initially, right? Like that's a really common determination that the steering council comes to. And so being able to have kind of like a standardized way that people do a PIP prototype outside of the standard library, so things like creating a repo and like having all of this existing infrastructure setup and maybe even hosting it under the Python GitHub organization to give it some like air of officiality of like, yeah, this is something like really big is happening here. It's not just like someone in a corner writing something, right? Like giving some more grandiosity to the work that's being done and not just kind of saying, oh, go away, like that isn't an issue, right? But that's kind of how it can land sometimes. Right. And maybe setting up people for success, at least this is what we're going to expect from you. If you go through this process, then you've got you're further down the pipeline of having that conversation for a PIP. Yeah, definitely. And like, if you're wanting to write something that is for Python, you probably don't necessarily care about like setting up these exact workflows for publishing to PIPi. Like that's just a whole bunch of things that are in your way to actually being successful. So having that all be figured out already ahead of time for you makes things a lot easier for you. Yeah, yeah, yeah. Let's finish out with Yuri. Sure. So when I was a presentation, efficient data sharing between seven interpreters, and it's interesting because we talked about free threaded Python. But the year before the big news was sub interpreters and Eric Snow's work, and those are not directly competing type of things. But in a sense, they're kind of competing. Yeah, they're definitely competing for being like the model of how to do efficient, you know, parallelism in Python. Yeah, yeah. How do we isolate the stuff so that we can avoid the guilt? We take it out and add different algorithms, or do we just make copies of the interpreter and run them in isolation? But then you have this data sharing issue. I can't just share a pointer easily, right? So what's this about? Yeah, so Yuri basically came with this was also if you want the extended version, Yuri also gave like an actual PyCon talk about this library that he's developed called Mem Hive. Like Mem Hive, yeah. All right, awesome. And just for everyone listening, just this week, last week, recently, all the videos of all the talks are now available on YouTube. So it's been a while coming, but you can go watch it now. Exactly. So go watch them all. If you missed out on a talk, go watch them. But yeah, this so this library in particular is it's basically a way using immutable data structures. There's this immutable data structure called an H A M T. I actually don't know what it's short for, but it's a sent hash hash array map tree. There we go. Isn't that I wrote it down. And it's essentially like a way to have this tree that can be passed around and shared without like worrying what the other processes sub interpreters are, they're not processes. The other sub interpreters are doing to the status structure. So it enables a more efficient and safe way of sharing data. That's kind of like in a tree structure. And I think one the demo that you ended up giving was about a dictionary like data structure, where you know, you have a million keys and a bunch of sub interpreter workers working on that data. And they're able to, because it is using this immutable data structure, the modifications and changes are all safe. But it's also like super scalable and performant. Yeah. Yeah. The thing about parallelism and multi threading is if it's immutable, you can have many things as you want reading from the same memory. It's only when they start writing, does it matter? So exactly. Yeah, this this like has a way a mechanism to capture the rights in a way that is safe so that like the current one can see what has been written. And then the other ones aren't affected because their copy is not changed. Okay, that sounds very interesting. We talked about the coming compatibility matrix of free threaded Python. This won't have that issue, right? This operates in the every version of Python. Yeah, so this, I would assume that this sort of module would be able to say like, I am ready for a Gil free world. So that's like the mechanism that I believe C Python has has adopted for saying that your C C module is ready for not having a Gil, you actually have to opt into it. And then that module will will be allowed to run in a free threaded Python. Yeah, it's something I recently learned is there's separate wheeled builds for free threaded Python as well. Yeah, that's that's interesting. Yeah, it's its own, I don't know exactly the phrase for it. But yeah, it's own wheel tag platform target or whatever. Yeah, yeah, like free threaded gets appended to you know, Mac OS arm 64 or whatever. Exactly. Yeah, awesome. All right, Jeff, this has been great. How about some parting thoughts? Let's close this out was just takeaways from from the whole experience. Yeah, I mean, the language summit is lovely. And one of the things that's like most important to me is like this whole aspect of storytelling. And so that's why I felt really, really happy that I was invited along to be able to tell these stories to all of you. And I think that having all of these different narratives all in one place of all of these huge themes about what Python is going through all at once, right? Like, it's really incredible how many different things are happening in Python all at once. And like sometimes when you're focusing on just one or just two, you know, you don't have this huge context of, wow, Python is changing in like at least 20 different ways all at once. And we're somehow doing really, really well, I would say, like, yeah, I have no doubt about any of any of these huge changes that Python is going through, like to take in the wrong direction, like I'm feeling hopeful and excited about all of them. So it's an exciting time. Yeah, I am as well. And it is really tricky to get a picture, a holistic picture of the progress, because there's a lot of different groups doing different things. And there's no one person or one company's job to get somebody to come and tell that story. So yeah, thanks for giving us the insight here. It's been awesome. Yeah, thanks to be on the show. And I'm sure we'll have you back soon. Sounds good. Thanks for having you. See you. This has been another episode of Talk Python to me. Thank you to our sponsors. We're sure to check out what they're offering. It really helps support the show. This episode is sponsored by Posit Connect from the makers of Shiny. Publish, share and deploy all of your data projects that you're creating using Python, Streamlet, dash, shiny, bokeh, fast API, flash, corto, reports, dashboards, and APIs. Posit Connect supports all of them. Try Posit Connect for free by going to talk by thon.fm slash Posit, POS IT. When to level up your Python, we have one of the largest catalogs of Python video courses over at Talk Python. Our content ranges from true beginners to deeply advanced topics like memory and async. And best of all, there's not a subscription in sight. Check it out for yourself at training.talk by thon.fm. Be sure to subscribe to the show, open your favorite podcast app and search for Python. We should be right at the top. You can also find the iTunes feed at slash iTunes, the Google Play feed at slash play, and the direct RSS feed at slash RSS on talk by thon.fm. We're live streaming most of our recordings these days. If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talk Python.fm slash YouTube. This is your host Michael Kennedy. Thanks so much for listening. I really appreciate it. Now get out there and write some Python code.